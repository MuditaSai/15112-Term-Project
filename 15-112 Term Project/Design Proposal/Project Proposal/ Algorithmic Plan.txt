
I will be using Kruskal’s to implement the maze generation algorithm and Dijkstra’s to implement the path-finding algorithm (helps the monster track down the player’s current location) as well as the path to the exit.

Maze generation algorithm:

- A square grid of size nxn is created (size increases as the level increases) - view representation.

- View → Model: A graphical representation of the grid is created - the indices are the nodes; the horizontal and vertical neighbors of the nodes are the edges. 

- Every (row,col) index is mapped as a dictionary of the overall larger dictionary (the grid itself).

- My Kruskal’s function will take the graph of the grid (essentially a dictionary) and output a new graph of all the connected indices (nodes).

- Model → View: The graph generated by Kruskal is now translated onto the grid, hence creating a maze
.
Path-finding algorithm:

- My Dijkstra’s function will take in the graph generated by Kruskal to find the shortest possible path to the exit of the dungeon.
 
- A list of all the nodes / (row,col) indices is output. This is the list containing the indices / path that the monster should take in order to reach the exit before the player does. 

